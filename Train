import torch.nn as nn
from Dataset import  traindataset, evaldataset
from torch.utils.data import DataLoader
from Model import Bert_cls
from torch import optim
import torch
import torch.utils.tensorboard as Tensorboard
import os
import shutil
import loralib as lora


root = './datas/train/labeledTrainData.tsv'

trainset = traindataset(root)
trainloader = DataLoader(trainset, batch_size=32, shuffle=True)
evalset = evaldataset(root)
evalloader = DataLoader(evalset, batch_size=16, shuffle=False)

net = Bert_cls()
# lora.mark_only_lora_as_trainable(net)
# 训练过程可视化
if os.path.exists('net_logs'):
    shutil.rmtree('net_logs')

writer = Tensorboard.SummaryWriter('net_logs')
writer.add_graph(net,torch.tensor([101 for i in range(512)]).unsqueeze(0))

# 将模型转移到GPU上
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
print(device)
net.to(device)


Loss = nn.CrossEntropyLoss()

epochs = 16
loss_av_nums = 2
for epoch in range(epochs):
    net.train()

    _loss = 0
    if epoch < 4:
        lr = 5e-5
    else:
        if epoch < 8:
            lr = 3e-5
        else:
            lr = 1e-5

    opt = optim.Adam(net.parameters(), lr=lr)
    for i, (sentences,tar) in enumerate(trainloader, 0):
        sentences = sentences.to(device);tar = tar.to(device)
        pre = net(sentences)
        loss = Loss(pre, tar)
        opt.zero_grad()
        loss.backward()
        opt.step()
        _loss += loss.item()

        if i % loss_av_nums==0 and i != 0:
            print('[{}/{}] [{}/{}]:loss = {}'.format(epoch,epochs,i,len(trainloader),_loss/loss_av_nums))
            writer.add_scalar('train/loss', _loss / loss_av_nums, i + epoch * len(trainloader))
            _loss = 0

    net.eval()
    total_accuracy = 0
    with torch.no_grad():
        for i, (sentences,tar) in enumerate(evalloader, 0):
            sentences = sentences.to(device);tar = tar.to(device)
            tar = tar.to(device)
            pre = net(sentences)
            accuracy = (pre.argmax(1) == tar.argmax(1)).sum()
            total_accuracy += accuracy

        total_evals = 16 * len(evalloader)
        writer.add_scalar('train/accuracy', total_accuracy/total_evals, epoch)
        print('accuray = {}'.format(total_accuracy/total_evals))

net.to('cpu')
torch.save(net.state_dict(), 'net.pth')
writer.close()

